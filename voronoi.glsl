#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

// for loop에서 인덱스값을 인자로 받아 
// vec2 타입의 세포핵 좌표값을 랜덤으로 자동생성 해주는 랜덤함수
vec2 random(float f) {
  // x, y값은 우리가 이전 예제들에서 랜덤값 생성하는 공식과 동일한 걸 사용하면 됨.
  float x = fract(sin(f * 1306.346) * 1652.12124);
  float y = fract(cos(f * 2407.125) * 2105.12569);

  return vec2(x, y); // 랜덤하게 생성된 세포핵 좌표값을 리턴해줌.
}

void main() {
  vec2 coord = gl_FragCoord.xy / u_resolution; // 각 픽셀들 좌표값 normalize
  coord.x *= u_resolution.x / u_resolution.y; // 캔버스를 resizing 해도 왜곡이 없도록 좌표값에 해상도비율값 곰해줌.

  // 마지막 세포핵은 마우스의 위치값에 따라 움직이도록 할 것이기 때문에
  // glsl-canvas가 제공하는 특수한 유니폼 변수 u_mouse 를 사용해서 마우스 위치값을 받아옴.
  vec2 mouse = u_mouse / u_resolution; // 이 때, u_mouse는 normalize된 좌표값이 아니기 때문에, coord에 각 픽셀들 좌표값 계산할 때처럼 normalize를 해줌.
  mouse.x *= u_resolution.x / u_resolution.y; // 마찬가지로, 해상도비율값을 곱해줘서 resizing 해도 마우스 좌표값 왜곡이 없도록 함. 

  // 세포핵 좌표값을 자동생성하도록 리팩토링 했으므로, num 값만 바꿔주면 알아서 해당 개수만큼 voronoi 다각형을 그려줌.
  const int num = 10; // 세포핵의 개수 (int 타입이니까 5옆에 .(소수점) 을 안붙여도 됨.)
  vec2 cells[num]; // 세포핵 좌표값 vec2를 넣어줄 비어있는 vec2 배열을 생성함. 세포를 5개 그릴거니까 배열 길이도 5개로 함.

  // 각 세포핵 좌표값을 자동생성 하도록 리팩토링 함.
  // 세포핵 개수만큼 for loop를 돌면서 index 정수값을 실수로 변환하여 매개변수로 넣어주면 
  // 랜덤한 vec2 값을 리턴받는 랜덤함수를 사용해서 자동생성 할거임.
  for(int i = 0; i < num - 1; i++) { // 마지막 번째 세포핵 좌표값은 랜덤값을 받지 않을거니까 num - 1 까지만 반복해 줌.
    // int 데이터인 인덱스값을 float 데이터로 변환한 후, 랜덤함수의 인자로 전달해 줌.
    cells[i] = random(float(i));
  }

  // 마지막 번째 세포핵 좌표값은 랜덤함수로 리턴받는 게 아니라,
  // 마우스의 움직이는 좌표값으로 할당해주도록 함.
  cells[num - 1] = mouse; 

  /*
    아래에도 설명했다시피,
    보로노이 다각형은 결국 각 픽셀들이 갖고 있는 좌표가
    어느 세포핵과 가장 가까운가를 테스트하는 게 핵심적인 컨셉(?)이기 때문에
    
    5개의 세포핵을 for loop를 돌려서
    distance() 내장함수 같은거로 현재 픽셀과의 거리값을 비교해보고,
    가장 가까운 거리값을 찾아내야겠지.

    참고로, 이 계산에서 사용할 float md값은
    min distance(최소 거리값)을 의미함.

    즉, 이렇게 100으로 초기화된 최소거리값에서 시작해서
    세포핵 개수만큼의 for loop를 돌리면서
    더 가까운 세포핵과의 거리값을 찾아냈다면
    최소거리값을 해당 세포와의 거리값으로 계속 갱신해가면서
    
    마침내 가장 가까운 세포핵과의 거리값, 즉 가장 짧은, 최소한의 거리값(min distance)
    를 추적해나가는 원리라고 생각하면 됨.

    근데 이 예제에서는 md가 100이니까
    어떤 세포핵과 거리값을 재보던지 100보다는 짧을 수밖에 없겠지
    왜냐면 coord값은 이미 0 ~ 1 사이로 정규화 되어있고,
    세포핵들의 좌표값도 0 ~ 1 사이의 값들이니까
    두 좌표 사이의 거리가 100을 넘을 수가 없음.

    따라서 5개의 세포핵을 반복문으로 돌려보면
    픽셀과 거리를 재보던지 간에 무조건 if block을 통과해서 
    md값이 갱신되도록 한 것임.

    모든 픽셀들이 5개의 세포핵과의 각 거리값이 100보다는 짧으니까!
    즉, 모든 픽셀들이 5개의 세포핵 중 하나에는 포함되도록 한거지.

    근데 만약, md값을 0 ~ 1 사이의 값, 예를 들면 0.2 이런 값으로 넣어버리면?
    캔버스의 픽셀들 중 어느 세포에도 포함되지 못하는 픽셀들이 생겨버림.
    왜냐면 캔버스의 좌표값이 0 ~ 1이고, 세포핵의 좌표값도 0 ~ 1 사이라면
    아무래도 모든 5개의 세포핵과의 거리를 재봐도 0.2를 넘는 픽셀이 생길 수밖에 없을테니까...
    이런 경우에는 그냥 초기의 md값인 0.2가 픽셀의 색상값으로 그대로 박혀버리게 되겠지. 
  */
  float md = 100.;
  vec2 picked_cell;
  for(int i = 0; i < num; ++i) { // 세포핵 개수만큼 for loop를 돌려 현재 픽셀과 각 세포핵들과의 거리값을 체크해봄.
    float d = distance(cells[i], coord); // 각 세포핵들과 현재 픽셀과의 거리값을 구함.

    if(d < md) {
      // 만약, 현재 픽셀과 현재 for loop를 돌고있는 세포핵과의 거리값이 
      // md값보다 가깝다면, md를 해당 거리값으로 갱신한 뒤, 다음 반복문으로 넘어감.
      // 그러면 다음 반복문의 md값은 그전까지 돌았었던 for loop들 중에서
      // 가장 가까운 세포핵과의 거리값이 저장되어 있는 상태겠지.
      // 근데 만약 다음 반복문에서 더 가까운 세포핵과의 거리값을 찾았다? 그럼 또 갱신해주는거야.
      // 이런 식으로 md값을 점점 추적하여 갱신해 나가면서 가장 가까운 세포핵과의 거리값이
      // md에 저장될 수 있도록 하는 것이지!
      md = d;

      // 각 보로노이 다각형에 색상을 추가할 때 사용하기 위해,
      // 현재 픽셀과 가장 가까운 세포핵의 좌표값을 저장해 둠.
      picked_cell = cells[i];
    }
  }

  // 해당 픽셀과 가장 가까운 세포핵과의 거리값으로 색상값을 지정함.
  // 그렇게 된다면, 하나의 세포 안에서도
  // 세포핵과 가까운 픽셀일수록 거리값이 짧으니까 어두운 색상이 찍힐것이고,
  // 세포핵과 멀리 떨어진 픽셀일수록 거리값이 기니까 밝은 색상이 찍히겠지!
  // 여기에 플러스로, 
  // abs()와 sin()을 이용해서 노이즈값에 추가적인 계산을 해준 뒤, 그걸 색상의 b값으로 사용하고,
  // 현재 픽셀과 가장 가까운 세포핵의 좌표값을 picked_cell에 넣어서 색상의 r, g 값으로 넣어주면
  // 뭔가 색깔이 있는 동심원 패턴이 추가됨.
  // 여기에 플러스로,
  // 각 세포핵 좌표값의 정확한 위치를 알고 싶다면, 
  // md가 0.01보다 작은 경우, 즉 현재 픽셀과 각 세포핵과의 거리가 0.01보다 작다면
  // white 컬러로 찍히게 해줘서, 각 세포핵 위치마다 반지름이 0.01인 point를 그려줄 수도 있음.
  vec3 col = md < 0.01 ? vec3(1.) : vec3(picked_cell, abs(sin(md * 100.)));

  gl_FragColor = vec4(col, 1.);
}

/*
  보로노이(Voronoi) 다각형


  Voronoi는 다른 말로 Cellular Noise 라고도 함.
  노이즈 알고리즘의 한 종류라고 보면 됨.

  들로네 삼각분할(Delaunay triangulation) 이라는 개념과
  항상 짝지어서 같이 다닌다고 함.
  관련 내용은 구글링해서 찾아볼 것.

  이번 예제에서는 셰이더 상에서 보로노이 다각형을 그리는 방법만 알아볼 것임.


  보로노이 다각형의 원리를 간단하게 알아보면
  각 다각형을 세포라고 생각하고,
  각 다각형 내부에는 세포핵이 존재한다고 생각하면 됨.
  실제로 보로노이 다각형은 생김새가 가운데에 세포핵이 있는 세포처럼 생겼음.

  예를 들어 5개의 세포핵이 존재한다 치면,
  캔버스의 각 픽셀들의 좌표값들이 각각
  5개의 세포핵 중 어느 세포핵에 가장 가까운지 그 거리값을 판단한 뒤,
  가장 가까운 세포핵을 발견했다면,
  그 세포핵이 이루고 있는 세포로 해당 픽셀이 포함되도록 하는 거라고 보면 됨.
  
  그니까, 각 픽셀들은 가장 가까운 세포핵의 세포영역 중에 하나로
  그려지도록 색상값이 찍히겠지! 
*/
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

/*
  아래의 함수들은 뭐냐면,

  이제 한 격자 내에서 세포핵들이 움직여야 하는 상황임. 
  그런데 thebookofshaders.com 원본 코드에서는 u_time 유니폼 변수를
  sin() 함수에 넣어 주기성을 갖는 값을 이용해서 세포핵 좌표값을 움직여 줬음.

  하지만 튜토리얼 강의에서는
  직접 만든 노이즈 함수를 이용해서
  랜덤하고 연속적인 노이즈값을 리턴받아서
  그 값을 세포핵 좌표값으로 사용하여 세포핵을 움직여 주려는 거임.

  따라서, 경계가 흐물흐물하고 organic한 노이즈값이 필요할 것이니,
  shader-noise3 예제의 Gradient noise 를 만들 때 사용했던
  랜덤함수와 노이즈함수를 그대로 가져와서 사용하는 것임. 
*/

// 하나의 격자 안에 존재하는 4개의 꼭지점 좌표값들로부터 
// 각각 랜덤한 화살표 벡터값을 얻을 수 있는 vec2 / vec2 랜덤함수 (shader-noise3 랜덤함수 참고)
vec2 random(vec2 c_) {
  // 인자로 전달받은 꼭지점 좌표값을 임의의 vec2와 내적계산하고,
  // 그 결과값으로 fract(), sin() 내장함수를 이용해서 랜덤한 성분값을 계산하는 코드를 한줄로 축약한 것.
  // Gradient Noise 에서 사용한 랜덤함수와 똑같은 계산을 축약한 거라고 보면 됨.
  // 참고로, 1e5는 10의 5제곱을 의미하며, 100000 이라고 보면 됨. 이런 표기법을 scientific notation 이라고 함.
  float x = fract(sin(dot(c_, vec2(75.8, 45.6))) * 1e5);
  float y = fract(sin(dot(c_, vec2(85.8, 108.6))) * 1e5);

  vec2 returnVec = vec2(x, y); // 현재 리턴할 벡터값의 범위는 0 ~ 1
  returnVec = returnVec * 2. - 1.; // 벡터값 범위를 0 ~ 1에서 -1 ~ 1로 Mapping하는 작업. (화살표의 방향이 180도를 포함하도록 한 것.)
  return returnVec;
}

// 랜덤함수를 이용해 격자의 각 꼭지점 좌표로부터 랜덤한 vec2 데이터를 받은 뒤,
// Gradient Noise에 필요한 노이즈값을 계산해 줄 노이즈 함수 (shader-noise3 노이즈함수 참고)
float noise(vec2 coord) {
  vec2 i = floor(coord); // 전달된 픽셀 좌표값의 정수부분만 떼어낸 vec2
  vec2 f = fract(coord); // 전달된 픽셀 좌표값의 소수부분만 떼어낸 vec2

  // 참고로 여기서부터는 강의 영상에서는 축약된 코드를 사용했는데,
  // 그러면 코드를 알아보기가 어려울 것 같아서 shader-noise3 에서 풀어쓴 코드를 가져와 사용했음.

  // 전달된 픽셀 좌표 v가 포함된 격자 한 칸의 4개의 꼭지점 좌표값을 구함
  // 참고로, 좌하단 꼭지점 좌표값은 vec2 i와 동일하니 별도로 구할 필요는 없겠지
  vec2 i2 = i + vec2(1., 0.); // 우하단 꼭지점 좌표값
  vec2 i3 = i + vec2(0., 1.); // 좌상단 꼭지점 좌표값
  vec2 i4 = i + vec2(1., 1.); // 우상단 꼭지점 좌표값

  // 격자 한칸의 4개의 꼭지점 좌표값을 
  // 랜덤함수의 인자로 전달해서 랜덤한 화살표 벡터값을 얻음.
  vec2 r = random(i);
  vec2 r2 = random(i2);
  vec2 r3 = random(i3);
  vec2 r4 = random(i4);

  // 이제 각 꼭지점으로부터 출발하는 화살표 벡터 r, r2, r3, r4와
  // 각 꼭지점에서 현재 픽셀로 향하는 벡터 (ex. 첫 번째 꼭지점의 경우 coord - i)를 내적계산함.
  float d = dot(r, coord - i);
  float d2 = dot(r2, coord - i2);
  float d3 = dot(r3, coord - i3);
  float d4 = dot(r4, coord - i4);

  // smoothstep() 보다 더 노이즈 곡선을 완만하게 만드는 공식 알지? -> 이거로 노이즈의 경계선을 뭉개주는 것.
  f = f * f * f * (f * (f * 6. - 15.) + 10.); // 이 공식 잊지마세요.. 굉장히 중요함.
  // 아래의 두 연산도 smoothstep 대신 써주면 더 빠른 노이즈 계산이 가능하다고 함.
  // y = x * x * (3.0 - 2.0 * x); -> 얘는 smoothstep보다 계산은 빠른데 모양이 똑같음.
  // y = x * x * x * (x * (x * 6.0 - 15.0) + 10.0); -> 얘는 smoothstep 보다 계산도 빠르고 좀 더 스무스함.

  // 각 꼭지점들의 화살표 벡터와 내적계산한 결과값을 f.x 만큼의 비율로 mix해서 bot, top에 넣어주고,
  // bot과 top을 또 f.y 만큼의 비율로 mix 해서 최종적으로 리턴할 노이즈값을 계산함.
  float bot = mix(d, d2, f.x);
  float top = mix(d3, d4, f.x);
  float ret = mix(bot, top, f.y); // 최종 리턴할 노이즈값

  // shader-noise3 에서와 달리,
  // 리턴된 노이즈값을 색상값으로 사용하지 않기 때문에
  // 굳이 노이즈값의 범위를 -1 ~ 1 에서 0 ~ 1 로 Mapping 해줄 필요는 없음.
  return ret;
}

// 각 격자의 중심점 좌표값 vec2 center를 인자로 받은 뒤,
// 매 프레임마다 u_time에 의해 변화하는, 랜덤하게 리턴되는 노이즈값으로 구성된 vec2 데이터를 리턴하는 함수
// 이 함수가 리턴해주는 값이 매 프레임마다 변화하는 -1 ~ 1 사이의 vec2 벡터값이므로,
// 이 리턴값을 main 함수의 for loop에서 매 프레임마다 각 격자의 중심점 좌표값에 더해주면 
// 매 프레임마다 중심점을 기준으로 주기를 갖고 움직이는 세포핵 좌표값을 구할 수 있겠지!
vec2 noiseVec2(vec2 coord) {
  float time_speed = 0.3; // u_time의 속도를 0.3배로 늦춤
  float time_diff = dot(coord.x, coord.y); // 각 격자마다 세포핵의 속도 차이를 계산함. (참고로, dot(float, float)은 float * float 값을 리턴함.)
  coord += u_time * time_speed + time_diff; // 이렇게 계산된 coord값은 매 프레임마다, 그리고 격자마다 달라지겠지

  // 위에서 계산된 coord값에 각 성분마다 특정한 vec2 값을 더해준 다음,
  // 그 더해준 값을 인자로 하는 랜덤한 2개의 노이즈값을 각자 리턴받고,
  // 그 2개의 노이즈값을 성분으로 하는 vec2를 만들어 리턴해 줌. 
  // -> 그래서 함수 이름이 noiseVec2임. 2개의 랜덤한 노이즈값으로 만든 vec2를 리턴해주니까. 
  return vec2(noise(coord + vec2(10.55, 71.51)), noise(coord + vec2(-710.41, 150.65)));
}

void main() {
  vec2 coord = gl_FragCoord.xy / u_resolution; // 각 픽셀들 좌표값 normalize
  coord *= 10.; // 좌표계의 규모를 0 ~ 1 에서 0 ~ 4 으로 Mapping 시켜서 확대함. -> 캔버스의 격자를 4*4 칸으로 나눈 것.
  coord.x *= u_resolution.x / u_resolution.y; // 캔버스를 resizing 해도 왜곡이 없도록 좌표값에 해상도비율값 곰해줌.

  vec2 coord_i = floor(coord); // 현재 픽셀 좌표값의 정수부분만 떼어낸 vec2
  vec2 coord_f = fract(coord); // 현재 픽셀 좌표값의 소수부분만 떼어낸 vec2

  // 현재 프레임에서 현재 픽셀이 각 격자의 세포핵들과의 거리값 중 가장 가까운 거리값을 계속 추적 갱신해나갈 최소한의 거리값(min distance) 
  float md = 100.;  

  /*
    현재 픽셀이 포함된 현재 격자 주변의 9개의 픽셀을 조사하는 방법

    
    우선 9개의 격자만 조사하면 되니까, 
    2중 for loop를 각각 3번씩 돌려서 총 9번의 반복을 하는거지

    이때, 왜 굳이 2중 for loop로 돌리느냐면,
    vec2 center에 현재 픽셀이 속한 현재 격자를 중심으로,
    그것을 둘러싼 주변의 9개 격자들의 중심점들을 각 for loop마다 계산해줘야 하는데,
    아래와 같은 원리로 계산해줘야 하기 때문에 2중 for loop가 필요함.

    이제 coord_i는 현재 픽셀이 속한 현재 격자의 좌하단 꼭지점(즉, 원점)의 좌표값이겠지?
    여기에 vec2(-1., -1.)을 더하면 현재 격자를 중심으로 남서쪽 격자의 좌하단 꼭지점(원점)을 구할 수 있음.
    마찬가지 원리로, (2., 2.) 더하면 현재 격자를 중심으로 북동쪽 격자의 좌하단 꼭지점을 구할 수 있고!
    
    이런 원리로 -1 ~ 2 로 구성된 vec2(x, y) 좌표값을 더해주면서
    현재 격자를 포함한 주변 9개 격자들의 좌하단 꼭지점(원점) 좌표값을 구할 수 있음.
    
    이렇게 9개의 격자들의 좌하단 꼭지점을 구하고 나면, 
    거기에 vec2(0.5) 만 더해주면 각 격자들의 중심 좌표값을 구할 수 있는것임!

    그래서 위와 같은 계산에 필요한 x, y 성분값을 얻기 위해
    for loop를 2중으로 쪼개준 것임.
  */
  for(float y = -1.; y < 2.; y++) {
    for(float x = -1.; x < 2.; x++) {
      vec2 center = coord_i + vec2(x, y) + vec2(.5); // 9개 격자들의 중심점 좌표값을 구한 것.

      // 각 격자들의 중심점 좌표값으로 랜덤한 노이즈값 2개를 뽑아 만든 vec2 값을 리턴받음.
      // 이 때, temp값은 격자마다, 매 프레임마다 달라지게 되어있음.  
      vec2 temp = noiseVec2(center);

      vec2 cell = center + temp; // 각 격자의 중심점 좌표값에 temp값을 더해 현재 각 격자의 세포핵 좌표값을 구함.
      float d = distance(coord, cell); // 현재 프레임에서 현재 픽셀과 각 격자의 세포핵들 사이의 거리를 각각 구함.

      // 이제 일반적인 voronoi를 그리는 과정과 동일함.
      // 현재 프레임에서 각 격자의 세포핵 좌표값들 중에서 가장 가까운 거리값이 존재한다면
      // 더 가까운 애들을 계속 추적해나가면서 md에 그 거리값을 갱신하는거지 (이전 커밋 참고) 
      if(d < md) {
        md = d;
      }
    }
  }

  // 현재 프레임에서 현재 픽셀과 가장 가까운 세포핵과의 거리값으로 색상값을 지정함.
  // 하나의 세포 안에서 보자면, 
  // 현재 프레임에서 각 세포핵과 가까운 픽셀일수록 어두운 색상이 찍히고,
  // 각 세포핵과 먼 픽셀일수록 밝은 색상이 찍히겠지
  vec3 col = vec3(md);

  gl_FragColor = vec4(col, 1.);
}

/*
  무수히 많은 보로노이 다각형을 생성하고 싶을 땐 어떻게 해야 하나>


  예를 들어, 보로노이 다각형을 이용해서 
  particle system을 구현하고 싶은 경우,
  수백 개의 보로노이를 생성해야 함.

  그러나, 이전 예제에서 구현한 코드로 수백 개의 보로노이를 생성한다면
  눈에 띌 정도로 fps가 감소하는 걸 볼 수 있음.

  따라서, 이번 커밋에서는 무한히 많은 수의 보로노이를 
  성능저하 없이 생성하고 싶을 때 사용할 수 있는 방법에 대해 정리해 봄.

  
  일단 기본적인 원리는 다음과 같음 
  
  좌표계를 확대하기 위해 Mapping 하면,
  n * n 개의 격자들로 나누어지게 되는데,
  
  이 때, 현재 픽셀이 속해있는 격자 한 칸을 중심으로,
  그 격자의 주변을 둘러싼 격자들을 포함하여 
  총 9개의 격자들만 조사하는 방식임.

  multiple-voronoi.png 이미지를 참고하면,
  지금 분홍색 점이 현재 픽셀이고,
  그 주변의 9개의 격자들만 조사하게 되는 거라고 보면 됨.

  왜 주변의 9개의 격자들만 조사를 하냐?
  여러 개의 보로노이 다각형을 그릴 때에는,
  하나의 격자에는 하나의 세포핵만 포함할 수 있고,
  해당 세포핵은 해당 격자 안에서만 움직일 수 있다는 전제를 해야 함.
  multiple-voronoi-example.png 이미지를 보면 무슨 말인지 이해가 됨.

  그럴 때, 지금 분혹색 점이 포함된 격자안에 그린 원형이
  보로노이 다각형의 세포핵이 움직일 수 있는 반경이라고 가정한 것임.

  그렇게 본다면, 해당 세포핵이 해당 격자안의 반경에서 돌아다닐 때마다
  보로노이 다각형이 그려질 수 있는 반경 범위는
  해당 격자를 중심으로 한 주변의 9개의 격자로 한정되게 되어있음.
  그래서 9개의 격자들만 조사하는 것임.
*/

/*
  그래서 위와 같은 방식으로 
  여러 개의 보로노이 다각형을 그리게 되면
  
  coord *= n 해서 n값을 10으로 하든 100으로 하든
  격자의 칸수를 몇개로 늘려주던지 간에
  fps의 저하가 전혀 없음.

  왜냐? 아무리 격자의 칸수를 n*n 개로 무한히 늘리더라도,
  모든 픽셀들은 자신이 속한 격자를 포함해서 주변의 9개의 격자 내에서 
  움직이고 있는 세포들과의 거리만 조사하면 되기 때문에,  
  연산의 부하가 9번의 for loop로 한정됨.

  그래서 격자가 아무리 늘어나더라도 연산이 복잡해지지 않고
  연산의 복잡도는 차이가 없다!
*/

/*
  보로노이(Voronoi) 다각형


  Voronoi는 다른 말로 Cellular Noise 라고도 함.
  노이즈 알고리즘의 한 종류라고 보면 됨.

  들로네 삼각분할(Delaunay triangulation) 이라는 개념과
  항상 짝지어서 같이 다닌다고 함.
  관련 내용은 구글링해서 찾아볼 것.

  이번 예제에서는 셰이더 상에서 보로노이 다각형을 그리는 방법만 알아볼 것임.


  보로노이 다각형의 원리를 간단하게 알아보면
  각 다각형을 세포라고 생각하고,
  각 다각형 내부에는 세포핵이 존재한다고 생각하면 됨.
  실제로 보로노이 다각형은 생김새가 가운데에 세포핵이 있는 세포처럼 생겼음.

  예를 들어 5개의 세포핵이 존재한다 치면,
  캔버스의 각 픽셀들의 좌표값들이 각각
  5개의 세포핵 중 어느 세포핵에 가장 가까운지 그 거리값을 판단한 뒤,
  가장 가까운 세포핵을 발견했다면,
  그 세포핵이 이루고 있는 세포로 해당 픽셀이 포함되도록 하는 거라고 보면 됨.
  
  그니까, 각 픽셀들은 가장 가까운 세포핵의 세포영역 중에 하나로
  그려지도록 색상값이 찍히겠지! 
*/